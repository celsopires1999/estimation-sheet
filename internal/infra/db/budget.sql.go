// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: budget.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkInsertBudget = `-- name: BulkInsertBudget :exec
INSERT INTO
    budgets (
        budget_id,
        portfolio_id,
        cost_id,
        amount,
        created_at
    )
VALUES (
        unnest($1::text []),
        unnest($2::text []),
        unnest($3::text []),
        unnest($4::float8[]),
        unnest($5::timestamp[])
    )
`

type BulkInsertBudgetParams struct {
	Column1 []string
	Column2 []string
	Column3 []string
	Column4 []float64
	Column5 []pgtype.Timestamp
}

func (q *Queries) BulkInsertBudget(ctx context.Context, arg BulkInsertBudgetParams) error {
	_, err := q.db.Exec(ctx, bulkInsertBudget,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const bulkInsertBudgetAllocation = `-- name: BulkInsertBudgetAllocation :exec
INSERT INTO
    budget_allocations (
        budget_allocation_id,
        budget_id,
        allocation_date,
        amount,
        created_at
    )
VALUES (
        unnest($1::text []),
        unnest($2::text []),
        unnest($3::date[]),
        unnest($4::float8[]),
        unnest($5::timestamp[])
    )
`

type BulkInsertBudgetAllocationParams struct {
	Column1 []string
	Column2 []string
	Column3 []pgtype.Date
	Column4 []float64
	Column5 []pgtype.Timestamp
}

func (q *Queries) BulkInsertBudgetAllocation(ctx context.Context, arg BulkInsertBudgetAllocationParams) error {
	_, err := q.db.Exec(ctx, bulkInsertBudgetAllocation,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const deleteBudget = `-- name: DeleteBudget :execrows
DELETE FROM budgets WHERE budget_id = $1 RETURNING budget_id, portfolio_id, cost_id, amount, created_at, updated_at
`

func (q *Queries) DeleteBudget(ctx context.Context, budgetID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteBudget, budgetID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteBudgetAllocations = `-- name: DeleteBudgetAllocations :execrows
DELETE FROM budget_allocations WHERE budget_id = $1
`

func (q *Queries) DeleteBudgetAllocations(ctx context.Context, budgetID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteBudgetAllocations, budgetID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteBudgetsByPortfolioId = `-- name: DeleteBudgetsByPortfolioId :execrows
DELETE FROM budgets WHERE portfolio_id = $1
`

func (q *Queries) DeleteBudgetsByPortfolioId(ctx context.Context, portfolioID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteBudgetsByPortfolioId, portfolioID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findBudgetAllocations = `-- name: FindBudgetAllocations :many
SELECT budget_allocation_id, budget_id, allocation_date, amount, created_at, updated_at
FROM budget_allocations
WHERE
    budget_id = $1
ORDER BY allocation_date ASC
`

func (q *Queries) FindBudgetAllocations(ctx context.Context, budgetID string) ([]BudgetAllocation, error) {
	rows, err := q.db.Query(ctx, findBudgetAllocations, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BudgetAllocation
	for rows.Next() {
		var i BudgetAllocation
		if err := rows.Scan(
			&i.BudgetAllocationID,
			&i.BudgetID,
			&i.AllocationDate,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBudgetAllocationsGroupedByYear = `-- name: FindBudgetAllocationsGroupedByYear :many
SELECT EXTRACT(
        YEAR
        FROM budget_allocations.allocation_date
    )::int AS year, SUM(budget_allocations.amount)::float8 AS amount
FROM budget_allocations
WHERE
    budget_id = $1
GROUP BY
    year
ORDER BY year ASC
`

type FindBudgetAllocationsGroupedByYearRow struct {
	Year   int32
	Amount float64
}

func (q *Queries) FindBudgetAllocationsGroupedByYear(ctx context.Context, budgetID string) ([]FindBudgetAllocationsGroupedByYearRow, error) {
	rows, err := q.db.Query(ctx, findBudgetAllocationsGroupedByYear, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindBudgetAllocationsGroupedByYearRow
	for rows.Next() {
		var i FindBudgetAllocationsGroupedByYearRow
		if err := rows.Scan(&i.Year, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBudgetById = `-- name: FindBudgetById :one
SELECT budget_id, portfolio_id, cost_id, amount, created_at, updated_at FROM budgets WHERE budget_id = $1
`

func (q *Queries) FindBudgetById(ctx context.Context, budgetID string) (Budget, error) {
	row := q.db.QueryRow(ctx, findBudgetById, budgetID)
	var i Budget
	err := row.Scan(
		&i.BudgetID,
		&i.PortfolioID,
		&i.CostID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findBudgetsByPortfolioId = `-- name: FindBudgetsByPortfolioId :many
SELECT budget_id, portfolio_id, cost_id, amount, created_at, updated_at FROM budgets WHERE portfolio_id = $1
`

func (q *Queries) FindBudgetsByPortfolioId(ctx context.Context, portfolioID string) ([]Budget, error) {
	rows, err := q.db.Query(ctx, findBudgetsByPortfolioId, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Budget
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.BudgetID,
			&i.PortfolioID,
			&i.CostID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBudgetsByPortfolioIdWithRelations = `-- name: FindBudgetsByPortfolioIdWithRelations :many
SELECT
    bu.budget_id AS budget_id,
    bu.portfolio_id AS portfolio_id,
    co.cost_type AS cost_type,
    co.description AS description,
    co.comment AS comment,
    co.amount AS cost_amount,
    co.currency AS cost_currency,
    co.tax AS cost_tax,
    co.apply_inflation AS cost_apply_inflation,
    bu.amount AS amount,
    bu.created_at AS created_at,
    bu.updated_at AS updated_at
FROM budgets AS bu
    INNER JOIN costs AS co ON bu.cost_id = co.cost_id
WHERE
    bu.portfolio_id = $1
ORDER BY co.cost_type, co.description
`

type FindBudgetsByPortfolioIdWithRelationsRow struct {
	BudgetID           string
	PortfolioID        string
	CostType           string
	Description        string
	Comment            pgtype.Text
	CostAmount         float64
	CostCurrency       string
	CostTax            float64
	CostApplyInflation bool
	Amount             float64
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
}

func (q *Queries) FindBudgetsByPortfolioIdWithRelations(ctx context.Context, portfolioID string) ([]FindBudgetsByPortfolioIdWithRelationsRow, error) {
	rows, err := q.db.Query(ctx, findBudgetsByPortfolioIdWithRelations, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindBudgetsByPortfolioIdWithRelationsRow
	for rows.Next() {
		var i FindBudgetsByPortfolioIdWithRelationsRow
		if err := rows.Scan(
			&i.BudgetID,
			&i.PortfolioID,
			&i.CostType,
			&i.Description,
			&i.Comment,
			&i.CostAmount,
			&i.CostCurrency,
			&i.CostTax,
			&i.CostApplyInflation,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBudget = `-- name: InsertBudget :exec
INSERT INTO
    budgets (
        budget_id,
        portfolio_id,
        cost_id,
        amount,
        created_at
    )
VALUES ($1, $2, $3, $4, $5)
`

type InsertBudgetParams struct {
	BudgetID    string
	PortfolioID string
	CostID      string
	Amount      float64
	CreatedAt   pgtype.Timestamp
}

func (q *Queries) InsertBudget(ctx context.Context, arg InsertBudgetParams) error {
	_, err := q.db.Exec(ctx, insertBudget,
		arg.BudgetID,
		arg.PortfolioID,
		arg.CostID,
		arg.Amount,
		arg.CreatedAt,
	)
	return err
}

const insertBudgetAllocation = `-- name: InsertBudgetAllocation :exec
INSERT INTO
    budget_allocations (
        budget_allocation_id,
        budget_id,
        amount,
        allocation_date,
        created_at
    )
VALUES ($1, $2, $3, $4, $5)
`

type InsertBudgetAllocationParams struct {
	BudgetAllocationID string
	BudgetID           string
	Amount             float64
	AllocationDate     pgtype.Date
	CreatedAt          pgtype.Timestamp
}

func (q *Queries) InsertBudgetAllocation(ctx context.Context, arg InsertBudgetAllocationParams) error {
	_, err := q.db.Exec(ctx, insertBudgetAllocation,
		arg.BudgetAllocationID,
		arg.BudgetID,
		arg.Amount,
		arg.AllocationDate,
		arg.CreatedAt,
	)
	return err
}

const updateBudget = `-- name: UpdateBudget :exec
UPDATE budgets
SET
    portfolio_id = $2,
    cost_id = $3,
    amount = $4,
    updated_at = $5
WHERE
    budget_id = $1
`

type UpdateBudgetParams struct {
	BudgetID    string
	PortfolioID string
	CostID      string
	Amount      float64
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) error {
	_, err := q.db.Exec(ctx, updateBudget,
		arg.BudgetID,
		arg.PortfolioID,
		arg.CostID,
		arg.Amount,
		arg.UpdatedAt,
	)
	return err
}
