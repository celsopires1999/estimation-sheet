// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: workload.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkInsertWorkload = `-- name: BulkInsertWorkload :exec
INSERT INTO
    workloads (
        workload_id,
        portfolio_id,
        effort_id,
        hours,
        created_at
    )
VALUES (
        unnest($1::text []),
        unnest($2::text []),
        unnest($3::text []),
        unnest($4::int[]),
        unnest($5::timestamp[])
    )
`

type BulkInsertWorkloadParams struct {
	Column1 []string
	Column2 []string
	Column3 []string
	Column4 []int32
	Column5 []pgtype.Timestamp
}

func (q *Queries) BulkInsertWorkload(ctx context.Context, arg BulkInsertWorkloadParams) error {
	_, err := q.db.Exec(ctx, bulkInsertWorkload,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const bulkInsertWorkloadAllocation = `-- name: BulkInsertWorkloadAllocation :exec
INSERT INTO
    workload_allocations (
        workload_allocation_id,
        workload_id,
        allocation_date,
        hours,
        created_at
    )
VALUES (
        unnest($1::text []),
        unnest($2::text []),
        unnest($3::date[]),
        unnest($4::int[]),
        unnest($5::timestamp[])
    )
`

type BulkInsertWorkloadAllocationParams struct {
	Column1 []string
	Column2 []string
	Column3 []pgtype.Date
	Column4 []int32
	Column5 []pgtype.Timestamp
}

func (q *Queries) BulkInsertWorkloadAllocation(ctx context.Context, arg BulkInsertWorkloadAllocationParams) error {
	_, err := q.db.Exec(ctx, bulkInsertWorkloadAllocation,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const deleteWorkload = `-- name: DeleteWorkload :execrows
DELETE FROM workloads WHERE workload_id = $1 RETURNING workload_id, portfolio_id, effort_id, hours, created_at, updated_at
`

func (q *Queries) DeleteWorkload(ctx context.Context, workloadID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteWorkload, workloadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteWorkloadAllocations = `-- name: DeleteWorkloadAllocations :execrows
DELETE FROM workload_allocations WHERE workload_id = $1
`

func (q *Queries) DeleteWorkloadAllocations(ctx context.Context, workloadID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteWorkloadAllocations, workloadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteWorkloadsByPortfolioId = `-- name: DeleteWorkloadsByPortfolioId :execrows
DELETE FROM workloads WHERE portfolio_id = $1
`

func (q *Queries) DeleteWorkloadsByPortfolioId(ctx context.Context, portfolioID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteWorkloadsByPortfolioId, portfolioID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findWorkloadAllocations = `-- name: FindWorkloadAllocations :many
SELECT workload_allocation_id, workload_id, allocation_date, hours, created_at, updated_at
FROM workload_allocations
WHERE
    workload_id = $1
ORDER BY allocation_date ASC
`

func (q *Queries) FindWorkloadAllocations(ctx context.Context, workloadID string) ([]WorkloadAllocation, error) {
	rows, err := q.db.Query(ctx, findWorkloadAllocations, workloadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkloadAllocation
	for rows.Next() {
		var i WorkloadAllocation
		if err := rows.Scan(
			&i.WorkloadAllocationID,
			&i.WorkloadID,
			&i.AllocationDate,
			&i.Hours,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWorkloadById = `-- name: FindWorkloadById :one
SELECT workload_id, portfolio_id, effort_id, hours, created_at, updated_at FROM workloads WHERE workload_id = $1
`

func (q *Queries) FindWorkloadById(ctx context.Context, workloadID string) (Workload, error) {
	row := q.db.QueryRow(ctx, findWorkloadById, workloadID)
	var i Workload
	err := row.Scan(
		&i.WorkloadID,
		&i.PortfolioID,
		&i.EffortID,
		&i.Hours,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findWorkloadsByPortfolioId = `-- name: FindWorkloadsByPortfolioId :many
SELECT workload_id, portfolio_id, effort_id, hours, created_at, updated_at FROM workloads WHERE portfolio_id = $1
`

func (q *Queries) FindWorkloadsByPortfolioId(ctx context.Context, portfolioID string) ([]Workload, error) {
	rows, err := q.db.Query(ctx, findWorkloadsByPortfolioId, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workload
	for rows.Next() {
		var i Workload
		if err := rows.Scan(
			&i.WorkloadID,
			&i.PortfolioID,
			&i.EffortID,
			&i.Hours,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWorkloadsByPortfolioIdWithRelations = `-- name: FindWorkloadsByPortfolioIdWithRelations :many
SELECT
    w.workload_id AS workload_id,
    w.portfolio_id AS portfolio_id,
    c.code AS competence_code,
    c.name AS competence_name,
    e.comment AS comment,
    w.hours AS hours,
    w.created_at AS created_at,
    w.updated_at AS updated_at
FROM
    workloads AS w
    INNER JOIN efforts AS e ON w.effort_id = e.effort_id
    INNER JOIN competences AS c ON e.competence_id = c.competence_id
WHERE
    w.portfolio_id = $1
ORDER BY c.code
`

type FindWorkloadsByPortfolioIdWithRelationsRow struct {
	WorkloadID     string
	PortfolioID    string
	CompetenceCode string
	CompetenceName string
	Comment        pgtype.Text
	Hours          int32
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) FindWorkloadsByPortfolioIdWithRelations(ctx context.Context, portfolioID string) ([]FindWorkloadsByPortfolioIdWithRelationsRow, error) {
	rows, err := q.db.Query(ctx, findWorkloadsByPortfolioIdWithRelations, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindWorkloadsByPortfolioIdWithRelationsRow
	for rows.Next() {
		var i FindWorkloadsByPortfolioIdWithRelationsRow
		if err := rows.Scan(
			&i.WorkloadID,
			&i.PortfolioID,
			&i.CompetenceCode,
			&i.CompetenceName,
			&i.Comment,
			&i.Hours,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWorkload = `-- name: InsertWorkload :exec
INSERT INTO
    workloads (
        workload_id,
        portfolio_id,
        effort_id,
        hours,
        created_at
    )
VALUES ($1, $2, $3, $4, $5)
`

type InsertWorkloadParams struct {
	WorkloadID  string
	PortfolioID string
	EffortID    string
	Hours       int32
	CreatedAt   pgtype.Timestamp
}

func (q *Queries) InsertWorkload(ctx context.Context, arg InsertWorkloadParams) error {
	_, err := q.db.Exec(ctx, insertWorkload,
		arg.WorkloadID,
		arg.PortfolioID,
		arg.EffortID,
		arg.Hours,
		arg.CreatedAt,
	)
	return err
}

const insertWorkloadAllocation = `-- name: InsertWorkloadAllocation :exec
INSERT INTO
    workload_allocations (
        workload_allocation_id,
        workload_id,
        hours,
        allocation_date,
        created_at
    )
VALUES ($1, $2, $3, $4, $5)
`

type InsertWorkloadAllocationParams struct {
	WorkloadAllocationID string
	WorkloadID           string
	Hours                int32
	AllocationDate       pgtype.Date
	CreatedAt            pgtype.Timestamp
}

func (q *Queries) InsertWorkloadAllocation(ctx context.Context, arg InsertWorkloadAllocationParams) error {
	_, err := q.db.Exec(ctx, insertWorkloadAllocation,
		arg.WorkloadAllocationID,
		arg.WorkloadID,
		arg.Hours,
		arg.AllocationDate,
		arg.CreatedAt,
	)
	return err
}

const updateWorkload = `-- name: UpdateWorkload :exec
UPDATE workloads
SET
    portfolio_id = $2,
    effort_id = $3,
    hours = $4,
    updated_at = $5
WHERE
    workload_id = $1
`

type UpdateWorkloadParams struct {
	WorkloadID  string
	PortfolioID string
	EffortID    string
	Hours       int32
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) UpdateWorkload(ctx context.Context, arg UpdateWorkloadParams) error {
	_, err := q.db.Exec(ctx, updateWorkload,
		arg.WorkloadID,
		arg.PortfolioID,
		arg.EffortID,
		arg.Hours,
		arg.UpdatedAt,
	)
	return err
}
