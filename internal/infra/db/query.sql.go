// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCost = `-- name: CreateCost :exec
INSERT INTO
    costs (
        cost_id,
        project_id,
        cost_type,
        description,
        comment,
        amount,
        currency,
        created_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
`

type CreateCostParams struct {
	CostID      string
	ProjectID   string
	CostType    string
	Description string
	Comment     pgtype.Text
	Amount      float64
	Currency    string
	CreatedAt   pgtype.Timestamp
}

func (q *Queries) CreateCost(ctx context.Context, arg CreateCostParams) error {
	_, err := q.db.Exec(ctx, createCost,
		arg.CostID,
		arg.ProjectID,
		arg.CostType,
		arg.Description,
		arg.Comment,
		arg.Amount,
		arg.Currency,
		arg.CreatedAt,
	)
	return err
}

const createInstallment = `-- name: CreateInstallment :exec
INSERT INTO
    installments (
        installment_id,
        cost_id,
        payment_date,
        amount,
        created_at
    )
VALUES ($1, $2, $3, $4, $5)
`

type CreateInstallmentParams struct {
	InstallmentID string
	CostID        string
	PaymentDate   pgtype.Date
	Amount        float64
	CreatedAt     pgtype.Timestamp
}

func (q *Queries) CreateInstallment(ctx context.Context, arg CreateInstallmentParams) error {
	_, err := q.db.Exec(ctx, createInstallment,
		arg.InstallmentID,
		arg.CostID,
		arg.PaymentDate,
		arg.Amount,
		arg.CreatedAt,
	)
	return err
}

const createInstallments = `-- name: CreateInstallments :exec
INSERT INTO
    installments (
        installment_id,
        cost_id,
        payment_date,
        amount,
        created_at
    )
VALUES (
        unnest($1::text []),
        unnest($2::text []),
        unnest($3::date[]),
        unnest($4::float8[]),
        unnest($5::timestamp[])
    )
`

type CreateInstallmentsParams struct {
	Column1 []string
	Column2 []string
	Column3 []pgtype.Date
	Column4 []float64
	Column5 []pgtype.Timestamp
}

func (q *Queries) CreateInstallments(ctx context.Context, arg CreateInstallmentsParams) error {
	_, err := q.db.Exec(ctx, createInstallments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const createProject = `-- name: CreateProject :exec
INSERT INTO
    projects (
        project_id,
        description,
        start_date,
        created_at
    )
VALUES ($1, $2, $3, $4)
`

type CreateProjectParams struct {
	ProjectID   string
	Description string
	StartDate   pgtype.Date
	CreatedAt   pgtype.Timestamp
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) error {
	_, err := q.db.Exec(ctx, createProject,
		arg.ProjectID,
		arg.Description,
		arg.StartDate,
		arg.CreatedAt,
	)
	return err
}

const getCost = `-- name: GetCost :one
SELECT cost_id, project_id, cost_type, description, comment, amount, currency, created_at, updated_at FROM costs WHERE cost_id = $1
`

func (q *Queries) GetCost(ctx context.Context, costID string) (Cost, error) {
	row := q.db.QueryRow(ctx, getCost, costID)
	var i Cost
	err := row.Scan(
		&i.CostID,
		&i.ProjectID,
		&i.CostType,
		&i.Description,
		&i.Comment,
		&i.Amount,
		&i.Currency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInstallments = `-- name: GetInstallments :many
SELECT
    installment_id,
    cost_id,
    payment_date,
    amount,
    created_at
FROM installments
WHERE
    cost_id = $1
`

type GetInstallmentsRow struct {
	InstallmentID string
	CostID        string
	PaymentDate   pgtype.Date
	Amount        float64
	CreatedAt     pgtype.Timestamp
}

func (q *Queries) GetInstallments(ctx context.Context, costID string) ([]GetInstallmentsRow, error) {
	rows, err := q.db.Query(ctx, getInstallments, costID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInstallmentsRow
	for rows.Next() {
		var i GetInstallmentsRow
		if err := rows.Scan(
			&i.InstallmentID,
			&i.CostID,
			&i.PaymentDate,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCost = `-- name: UpdateCost :exec
UPDATE costs
SET
    project_id = $2,
    cost_type = $3,
    description = $4,
    comment = $5,
    amount = $6,
    currency = $7,
    updated_at = $8
WHERE
    cost_id = $1
`

type UpdateCostParams struct {
	CostID      string
	ProjectID   string
	CostType    string
	Description string
	Comment     pgtype.Text
	Amount      float64
	Currency    string
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) UpdateCost(ctx context.Context, arg UpdateCostParams) error {
	_, err := q.db.Exec(ctx, updateCost,
		arg.CostID,
		arg.ProjectID,
		arg.CostType,
		arg.Description,
		arg.Comment,
		arg.Amount,
		arg.Currency,
		arg.UpdatedAt,
	)
	return err
}
